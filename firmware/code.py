"""Firmware for the HackPiano.

The HackPiano is a custom MIDI keyboard made by AfterNoon PM as his HackPad project.
"""

###########
# IMPORTS #
###########

# Board stuff
import board  # type: ignore

# MIDI stuff
import usb_midi  # type: ignore
import adafruit_midi
from adafruit_midi.note_on import NoteOn
from adafruit_midi.note_off import NoteOff
from adafruit_midi.control_change import ControlChange  # noqa

# OLED stuff
import busio  # type: ignore
import displayio  # type: ignore
import adafruit_displayio_ssd1306

# Keyboard/KMK stuff
from kmk.kmk_keyboard import KMKKeyboard  # type: ignore
from kmk.keys import KC  # type: ignore
from kmk.scanners import DiodeOrientation  # type: ignore
from kmk.extensions.button import Button  # type: ignore


#########
# SETUP #
#########

# Constants
VELOCITY = 127

# MIDI setup
midi = adafruit_midi.MIDI(usb_midi.ports[0], out_channel=0)

# Button setup
button_pin = board.D3

# OLED setup
OLED_SDA = board.D4
OLED_SCL = board.D5
i2c = busio.I2C(OLED_SCL, OLED_SDA)
displayio.release_displays()
display_bus = displayio.I2CDisplay(i2c, device_address=0x3C)
display = adafruit_displayio_ssd1306.SSD1306(display_bus, width=128, height=32)


######################
# MIDIKEYBOARD CLASS #
######################

class MidiKeyboard(KMKKeyboard):
	def __init__(self):
		super().__init__()
		self.row_pins = (board.D6, board.D7, board.D8, board.D10)
		self.col_pins = (board.D9, board.D0, board.D1, board.D2)
		self.diode_orientation = DiodeOrientation.COL2ROW

		# KC.N0 for custom logic. will handle later on in MidiKeyboard.process_key
		self.keymap = [
			[
				KC.NO, KC.NO, KC.NO, KC.NO,
				KC.NO, KC.NO, KC.NO, KC.NO,
				KC.NO, KC.NO, KC.NO, KC.NO,
				KC.NO, KC.NO, KC.NO, KC.NO,
			]
		]

		self.midi_note_map = {
			# Row 0
			0: 60,  # C4
			1: 61,  # C#4
			2: 62,  # D4
			3: 63,  # D#4
			# Row 1
			4: 64,  # E4
			5: 65,  # F4
			6: 66,  # F#4
			7: 67,  # G4
			# Row 2
			8: 68,  # G#4
			9: 69,  # A4
			10: 70,  # A#4
			11: 71,  # B4
		}

		self.transpose = 0
		self.sustain = False
		self.active_midi_notes = set()
		self.extensions.append(Button([button_pin]))

	def process_key(self, key):
		if 0 <= key.key_number <= 11:
			midi_note = self.midi_note_map[key.key_number]

			if key.pressed:
				if midi_note not in self.active_midi_notes:
					midi.send(NoteOn(midi_note + self.transpose, VELOCITY))
					self.active_midi_notes.add(midi_note + self.transpose)
					print(
						f"MIDI Note On: {midi_note + self.transpose} " +
						f"({self._get_note_name(midi_note + self.transpose)})"
					)
					# TODO: Update OLED with note playing
			else:
				if midi_note in self.active_midi_notes:
					midi.send(NoteOff(midi_note + self.transpose, 0))
					self.active_midi_notes.remove(midi_note + self.transpose)
					print(
						f"MIDI Note Off: {midi_note + self.transpose} " +
						f"({self._get_note_name(midi_note + self.transpose)})"
					)
					# TODO: Update OLED (clear note display)

		elif 12 <= key.key_number <= 15:
			if key.pressed:
				print(f"Control Key SW{key.key_number + 1} Pressed")
				self.transpose += \
					-12 if key.key_number == 12 else \
					1 if key.key_number == 13 else \
					12 if key.key_number == 14 else \
					-1 if key.key_number == 15 else 0
				if self.transpose < 0 or self.transpose > 0:
					# TODO: Update OLED with transposition
					...
				else:
					# TODO: Clear transposition on OLED
					...

			else:
				print(f"Control Key SW{key.key_number + 1} Released")

		# TODO: Handle push button = toggle sustain (MIDI CC 64)
		# TODO: Update OLED with sustain status

		return super().process_key(key)

	def _get_note_name(self, note_number: int) -> str:
		"""Convert a MIDI note number to its corresponding note name.
		This helper function was generated by Gemini.

		Args:
			note_number (int): Note number to be converted

		Returns:
			str: formatted note name
		"""
		note_names = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]
		octave = (note_number // 12) - 1  # MIDI note 0 is C-1, so C4 is octave 4
		note_in_octave = note_number % 12
		return f"{note_names[note_in_octave]}{octave}"


#############
# MAIN LOOP #
#############

keyboard = MidiKeyboard()

if __name__ == '__main__':
	keyboard.go()
